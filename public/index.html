<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale-1.0">
    <title>Offline Conversion Spreadsheet Upload Process</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Cloudflare-inspired aesthetic enhancements */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc; /* Light grey background */
            color: #333;
        }
        .card {
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px; /* Slightly less rounded corners */
            border: 1px solid #e2e8f0; /* Lighter border */
        }
        .btn-primary {
            transition: all 0.2s;
            background-color: #f58220; /* Cloudflare orange */
            color: white;
            font-weight: 600;
            border: none;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #e07218; /* Slightly darker orange on hover */
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-secondary {
            transition: all 0.2s;
            background-color: #4b5563; /* Dark Gray */
            color: white;
            font-weight: 500;
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #374151;
        }
        .btn-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-gemini {
            background-color: transparent;
            border: 1px solid #f58220;
            color: #f58220;
            padding: 4px 8px;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 9999px;
            transition: all 0.2s;
        }
        .btn-gemini:hover:not(:disabled) {
            background-color: #f58220;
            color: white;
        }

        .log-success {
            color: #4CAF50; /* Green */
        }
        .log-error {
            color: #FF5252; /* Red */
        }
        .log-info {
            color: #42A5F5; /* Blue */
        }
        /* Custom file input button styling to match brand */
        input[type="file"]::file-selector-button {
            background-color: #f58220;
            color: white;
            padding: 8px 16px;
            border-radius: 9999px; /* Full rounded for pill shape */
            border: none;
            font-size: 0.875rem; /* text-sm */
            font-weight: 600; /* font-semibold */
            cursor: pointer;
            margin-right: 1rem;
            transition: all 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #e07218;
        }
        /* Override Tailwind focus ring to use brand color */
        input:focus, select:focus, textarea:focus {
            border-color: #f58220 !important;
            box-shadow: 0 0 0 2px #fde6d4 !important; /* Light orange glow */
            outline: none;
        }
        .header-separator {
            border-bottom: 5px solid #f58220;
            margin-bottom: 2rem;
            padding-bottom: 0;
        }
        .autocomplete-suggestions {
            border: 1px solid #e2e8f0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
        }
        .suggestion-item:hover {
            background-color: #fef3e8; /* Very light orange */
        }
        .loading-spinner {
            border-color: rgba(245, 130, 32, 0.2); /* Light orange */
            border-top-color: #f58220; /* Solid orange */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        cloudflareOrange: '#f58220',
                        cloudflareDarkBlue: '#0f172a', /* A dark blue-black, similar to CF dashboard */
                        cloudflareGray: '#6b7280',
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-8 min-h-screen flex items-start justify-center bg-gray-50">

    <div class="w-full max-w-4xl space-y-8">
        <header class="text-center pb-0 header-separator">
            <div class="mb-4">
                <img src="https://cf-assets.www.cloudflare.com/dzlvafdwdttg/69wNwfiY5mFmgpd9eQFW6j/d5131c08085a977aa70f19e7aada3fa9/1pixel-down__1_.svg" 
                     alt="Cloudflare Logo" 
                     class="h-8 mx-auto" 
                     onerror="this.style.display='none'">
            </div>
            <h1 class="text-3xl md:text-4xl font-extrabold text-cloudflareDarkBlue mb-6">Offline Conversion Spreadsheet Upload Process</h1>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            
            <div class="lg:col-span-2 space-y-8">

                <!-- Card 1: Bulk List Upload -->
                <div class="p-6 bg-white card">
                    <h2 class="text-2xl font-bold text-cloudflareOrange mb-4">1. Bulk List Upload</h2>
                    <form id="importForm" class="space-y-6">
                        
                        <div class="relative">
                            <label for="programName" class="block text-sm font-medium text-cloudflareGray">Marketo Program Name</label>
                            <input type="text" id="programName" required class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" placeholder="e.g., Q4-Webinar-Import">
                            <p class="text-xs text-gray-500 mt-1">Program Member Status will be set by the column **Import Program Status**.</p>
                            <!-- Autocomplete Suggestions -->
                            <div id="programSuggestions" class="autocomplete-suggestions absolute z-10 w-full rounded-b-md hidden"></div>
                        </div>

                        
                        <div class="pt-4 border-t border-gray-200">
                            <label for="csvFile" class="block text-sm font-medium text-cloudflareGray mb-2">Select CSV File</label>
                            <input type="file" id="csvFile" accept=".csv" required class="block w-full text-sm text-cloudflareGray
                                file:mr-4 file:py-2 file:px-4
                                file:rounded-full file:border-0
                                file:text-sm file:font-semibold
                                file:bg-cloudflareOrange file:text-white
                                hover:file:bg-e07218 cursor-pointer">
                        </div>

                        
                        <div id="mappingArea" class="hidden pt-6 border-t border-gray-200 space-y-3">
                            <h3 class="text-lg font-semibold text-cloudflareDarkBlue">Field Mapping: CSV Column $\rightarrow$ Marketo Field</h3>
                            

</div>

                        
                        <button type="submit" id="importButton" class="w-full flex justify-center py-3 px-4 rounded-lg shadow-md text-lg text-white btn-primary hover:shadow-lg" disabled>
                            Submit to Marketo
                        </button>
                    </form>
                </div>

                <!-- Card 2: Manual Lead Entry -->
                <div class="p-6 bg-white card">
                    <h2 class="text-2xl font-bold text-cloudflareOrange mb-4">2. Manual Lead Entry</h2>

                    <!-- Voice Dictation Area -->
                    <div class="space-y-3 mb-6 p-4 bg-gray-50 rounded-lg border">
                        <label for="dictationInput" class="block text-sm font-medium text-cloudflareGray">Voice Dictation</label>
                        <div class="flex items-center space-x-2">
                            <button id="micButton" class="p-2 rounded-full bg-cloudflareOrange text-white hover:bg-e07218">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm-1 3a4 4 0 108 0V4a4 4 0 10-8 0v3zM10 15a1 1 0 001 1v.01a1 1 0 102 0V16a1 1 0 00-1-1h-1a1 1 0 00-1 1zm-4.192-3.808A1 1 0 004 12v.01a1 1 0 102 0V12a1 1 0 00-1.808-.588A7.002 7.002 0 002 11a1 1 0 100 2 5.002 5.002 0 019.236 2.39 1 1 0 101.91 0A7.002 7.002 0 0010.808 9.412 1 1 0 0010 9c-2.4 0-4.525 1.043-6.192 2.192zM14 12v.01a1 1 0 102 0V12a1 1 0 00-1.808-.588A7.002 7.002 0 0010 9c.1 0 .198.003.297.008a1 1 0 10.11-1.996A9.004 9.004 0 0010 7c-4.97 0-9 4.03-9 9a1 1 0 102 0 7 7 0 017-7c.18 0 .358.006.536.018a1 1 0 10.108-1.998A7.003 7.003 0 0010 7c-.68 0-1.336.096-1.96.273a1 1 0 10.374 1.968A5.002 5.002 0 0110 9c.2 0 .397.01.592.029a1 1 0 10.11-1.996A7.003 7.003 0 0010 7c-.1 0-.198-.003-.297-.008a1 1 0 10-.11 1.996A9.004 9.004 0 0010 11c2.4 0 4.525-1.043 6.192-2.192A1 1 0 0014 8v4z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <textarea id="dictationInput" class="block w-full rounded-md border-gray-300 shadow-sm p-2 border" rows="3" placeholder="Click mic to speak, e.g., 'John Smith at Cloudflare, email john.smith@cloudflare.com, title is Director...'"></textarea>
                        </div>
                        <p id="dictationStatus" class="text-xs text-gray-500">Status: Idle. Click mic to start.</p>
                        <button type="button" id="parseDictationButton" class="w-full btn-secondary py-2 px-4 rounded-lg shadow-md text-sm">
                            Parse Dictated Text ✨
                        </button>
                    </div>

                    <form id="manualImportForm" class="space-y-4">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <input type="hidden" id="utmSource" value="MKTO-Offline-Conversion">
                            <input type="hidden" id="manualRoleDescription">

                            <div>
                                <label for="manualFirstName" class="block text-sm font-medium text-cloudflareGray">First Name</label>
                                <input type="text" id="manualFirstName" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                            </div>
                            <div>
                                <label for="manualLastName" class="block text-sm font-medium text-cloudflareGray">Last Name</label>
                                <input type="text" id="manualLastName" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                            </div>
                            <div class="md:col-span-2">
                                <label for="manualEmail" class="block text-sm font-medium text-cloudflareGray">Email <span class="text-red-500">*</span></label>
                                <input type="email" id="manualEmail" required class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                            </div>
                            <div class="md:col-span-2 relative">
                                <label for="manualTitle" class="block text-sm font-medium text-cloudflareGray">Job Title</label>
                                <input type="text" id="manualTitle" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border pr-24">
                                <button type="button" id="describeTitleButton" class="btn-gemini absolute right-2 top-7">Describe Role ✨</button>
                            </div>
                            <div class="md:col-span-2">
                                <label for="manualCompany" class="block text-sm font-medium text-cloudflareGray">Company</label>
                                <input type="text" id="manualCompany" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                            </div>
                            <div class="md:col-span-2">
                                <label for="manualWebsite" class="block text-sm font-medium text-cloudflareGray">Website</label>
                                <input type="text" id="manualWebsite" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" placeholder="e.g., domain.com">
                            </div>
                            <div>
                                <label for="manualCountry" class="block text-sm font-medium text-cloudflareGray">Country</label>
                                <input type="text" id="manualCountry" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                            </div>
                            <div>
                                <label for="manualCampaignCode" class="block text-sm font-medium text-cloudflareGray">Campaign Code</label>
                                <input type="text" id="manualCampaignCode" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border">
                            </div>
                            <div class="md:col-span-2">
                                <label for="manualProgramStatus" class="block text-sm font-medium text-cloudflareGray">Program Status</label>
                                <input type="text" id="manualProgramStatus" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" placeholder="e.g., Registered, Attended">
                            </div>
                        </div>
                        <button type="submit" id="manualImportButton" class="w-full flex justify-center py-3 px-4 rounded-lg shadow-md text-lg text-white btn-primary hover:shadow-lg">
                            Submit Manual Lead
                        </button>
                    </form>
                </div>

                <!-- Card 3: Unstructured Data Parser -->
                <div class="p-6 bg-white card">
                    <h2 class="text-2xl font-bold text-cloudflareOrange mb-4">3. Unstructured Data Parser (Gemini)</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="unstructuredInput" class="block text-sm font-medium text-cloudflareGray">Paste Messy Data</label>
                            <textarea id="unstructuredInput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border" rows="5" placeholder="e.g., 'Jen from Acme Inc (jen@acme.com), Bob (bob@demo.org)'"></textarea>
                        </div>
                        <button type="button" id="processUnstructuredButton" class="w-full btn-secondary py-2 px-4 rounded-lg shadow-md text-sm">
                            Process Data ✨
                        </button>
                        <div>
                            <label for="structuredOutput" class="block text-sm font-medium text-cloudflareGray">Clean CSV Output (Ready for Upload)</label>
                            <textarea id="structuredOutput" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border bg-gray-50 font-mono" rows="5" readonly></textarea>
                            <button type="button" id="copyCsvButton" class="hidden w-full btn-primary py-2 px-4 rounded-lg shadow-md text-sm mt-2">
                                Copy to Clipboard
                            </button>
                        </div>
                    </div>
                </div>

            </div>

            
            <div class="lg:col-span-1 p-6 bg-gray-900 card border-gray-700">
                <h2 class="text-2xl font-bold text-gray-200 mb-4">Import Status Log</h2>
                <div id="statusLog" class="h-96 overflow-y-auto bg-black text-sm p-3 rounded-lg text-gray-200 font-mono space-y-1">
                    <p class="log-info">App Ready. Select a CSV or use manual entry.</p>
                </div>
            </div>
        </main>
    </div>

    <script type="text/javascript">
        // --- Global UI Elements ---
        const importForm = document.getElementById('importForm');
        const csvFile = document.getElementById('csvFile');
        const importButton = document.getElementById('importButton');
        const statusLog = document.getElementById('statusLog');
        const programNameInput = document.getElementById('programName');
        const mappingArea = document.getElementById('mappingArea');
        const programSuggestions = document.getElementById('programSuggestions');
        const manualImportForm = document.getElementById('manualImportForm');
        
        // Gemini Feature Elements
        const unstructuredInput = document.getElementById('unstructuredInput');
        const processUnstructuredButton = document.getElementById('processUnstructuredButton');
        const structuredOutput = document.getElementById('structuredOutput');
        const copyCsvButton = document.getElementById('copyCsvButton');
        const describeTitleButton = document.getElementById('describeTitleButton');
        const manualTitleInput = document.getElementById('manualTitle');
        const manualRoleDescriptionInput = document.getElementById('manualRoleDescription');

        // Voice Dictation Elements
        const micButton = document.getElementById('micButton');
        const dictationInput = document.getElementById('dictationInput');
        const dictationStatus = document.getElementById('dictationStatus');
        const parseDictationButton = document.getElementById('parseDictationButton');

        // Global State
        let MARKETO_FIELDS = []; // Dynamically populated by Worker
        let programSearchDebounce;
        let speechRecognition;

        // --- Utility Functions ---
        
        /**
         * Appends messages to the status log.
         * @param {string} message - The message content.
         * @param {string} type - 'info', 'success', or 'error'.
         */
        function logStatus(message, type = 'info') {
            const now = new Date();
            const time = now.toTimeString().split(' ')[0];
            const p = document.createElement('p');
            p.textContent = `[${time}] ${message}`;

            switch (type) {
                case 'success': p.classList.add('log-success'); break;
                case 'error': p.classList.add('log-error'); break;
                default: p.classList.add('log-info'); break;
            }
            statusLog.appendChild(p);
            statusLog.scrollTop = statusLog.scrollHeight; // Auto-scroll
        }

        /**
         * Shows a loading spinner on a button.
         * @param {HTMLButtonElement} button - The button to disable.
         * @param {string} loadingText - Text to show while loading.
         */
        function showLoading(button, loadingText = 'Loading...') {
            button.disabled = true;
            button.dataset.originalText = button.innerHTML;
            button.innerHTML = `
                <span class="flex items-center justify-center">
                    <svg class="loading-spinner h-5 w-5 mr-3 animate-spin rounded-full border-2" viewBox="0 0 24 24"></svg>
                    ${loadingText}
                </span>
            `;
        }

        /**
         * Restores a button to its original state.
         * @param {HTMLButtonElement} button - The button to restore.
         */
        function hideLoading(button) {
            button.disabled = false;
            if (button.dataset.originalText) {
                button.innerHTML = button.dataset.originalText;
            }
        }
        
        // --- 1. Bulk Upload Logic ---

        /**
         * Fetches the official field list from Marketo via the secure Cloudflare Worker.
         */
        async function fetchMarketoFields() {
            logStatus('Fetching Marketo field metadata from Worker /api/fields...', 'info');
            try {
                const response = await fetch('/api/fields', { method: 'GET' });
                if (!response.ok) throw new Error(`Worker field API failed: ${await response.text()}`);
                
                const data = await response.json();
                if (data.status === 'success' && Array.isArray(data.fields)) {
                    MARKETO_FIELDS = [{ value: '', label: '-- Ignore Column --' }];
                    data.fields.forEach(field => {
                        MARKETO_FIELDS.push({
                            value: field.rest.name,
                            label: `${field.displayName} (${field.rest.name})`
                        });
                    });
                    logStatus(`Loaded ${MARKETO_FIELDS.length - 1} Marketo fields.`, 'success');
                    return true;
                } else {
                    throw new Error('Marketo API did not return a valid field list.');
                }
            } catch (error) {
                logStatus(`CRITICAL ERROR: Failed to load Marketo fields.`, 'error');
                logStatus(error.message, 'error');
                MARKETO_FIELDS = [];
                return false;
            }
        }

        /**
         * Event listener for CSV file selection.
         * Triggers field fetching and header parsing.
         */
        csvFile.addEventListener('change', async () => {
            mappingArea.innerHTML = '';
            mappingArea.classList.add('hidden', 'loading');
            importButton.disabled = true;

            const file = csvFile.files[0];
            if (!file) return;
            
            // 1. Fetch Marketo fields if not already loaded
            if (MARKETO_FIELDS.length === 0) {
                const fieldsLoaded = await fetchMarketoFields();
                if (!fieldsLoaded) {
                    mappingArea.classList.remove('loading');
                    return;
                }
            }

            // 2. Read CSV header
            mappingArea.innerHTML = `<p class="text-center text-gray-500 py-4">Reading CSV headers...</p>`;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const headerLine = event.target.result.split('\n')[0];
                    const headers = headerLine.split(',').map(h => h.trim().replace(/['"]+/g, ''));
                    renderMappingUI(headers);
                    mappingArea.classList.remove('hidden', 'loading');
                    importButton.disabled = !importForm.checkValidity();
                } catch (e) {
                    logStatus('Error parsing CSV headers.', 'error');
                    mappingArea.classList.remove('loading');
                }
            };
            reader.readAsText(file.slice(0, 500)); // Read only first part
        });

        /**
         * Generates the HTML for the mapping table.
         * @param {string[]} headers - Array of CSV column headers.
         */
        function renderMappingUI(headers) {
            let html = `
                <div class="bg-gray-700 p-3 rounded-lg">
                    <div class="grid grid-cols-2 font-bold text-gray-200 border-b border-gray-600 pb-2 mb-2 p-2">
                        <div class="pl-2">CSV Column Name</div>
                        <div>Map to Marketo Field</div>
                    </div>
                    <div id="mappingList" class="space-y-2">
            `;
            headers.forEach((header, index) => {
                const normalizedHeader = header.toLowerCase().replace(/[^a-z0-9]/g, '');
                let defaultMarketoValue = '';
                
                const matchedField = MARKETO_FIELDS.find(field => 
                    field.value.toLowerCase() === normalizedHeader || 
                    field.label.toLowerCase().includes(normalizedHeader)
                );
                if (matchedField) defaultMarketoValue = matchedField.value;
                if (normalizedHeader === 'email') defaultMarketoValue = 'email';

                const isDisabled = (normalizedHeader === 'email') ? 'disabled' : '';
                const isRequired = (normalizedHeader === 'email') ? 'required' : '';

                html += `
                    <div class="grid grid-cols-2 items-center">
                        <div class="text-sm font-medium text-gray-100 bg-gray-800 p-2 rounded-l-md">${header}</div>
                        <select 
                            data-csv-header="${header}"
                            name="marketoField_${index}" 
                            class="mapping-select mt-1 block w-full rounded-r-md border-gray-600 shadow-sm p-2 border bg-gray-800 text-gray-100 ${isDisabled}"
                            ${isDisabled} ${isRequired}
                        >
                `;
                MARKETO_FIELDS.forEach(field => {
                    let selected = (field.value === defaultMarketoValue) ? 'selected' : '';
                    let emailDisabled = (normalizedHeader !== 'email' && field.value === 'email') ? 'disabled' : '';
                    html += `<option value="${field.value}" ${selected} ${emailDisabled}>${field.label}</option>`;
                });
                html += `</select></div>`;
            });
            html += `</div></div>`;
            mappingArea.innerHTML = html;
        }

        /**
         * Handles the final bulk import form submission.
         */
        importForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            showLoading(importButton, 'Sending Data to Worker...');
            logStatus('Starting secured import workflow...', 'info');

            const file = csvFile.files[0];
            const workerEndpoint = '/api/import';
            const programName = programNameInput.value.trim();
            if (!file) {
                logStatus('No file selected.', 'error');
                hideLoading(importButton);
                return;
            }

            const reader = new FileReader();
            reader.onload = async (event) => {
                const csvContent = event.target.result;
                const selectElements = document.querySelectorAll('#mappingList select.mapping-select');
                const mappings = {};
                let hasEmailMapping = false;
                
                selectElements.forEach(select => {
                    if (select.value !== '') {
                        mappings[select.dataset.csvHeader] = select.value;
                        if (select.value === 'email') hasEmailMapping = true;
                    }
                });
                
                if (!hasEmailMapping) {
                    logStatus('Validation Failed: CSV must have a column mapped to "email".', 'error');
                    hideLoading(importButton);
                    return;
                }
                
                try {
                    const mappedCsvContent = transformCsvForMarketo(csvContent, mappings);
                    logStatus(`Sending ${file.name} to Worker...`, 'info');
                    
                    const response = await fetch(workerEndpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            csvContent: mappedCsvContent,
                            lookupField: 'email',
                            programName: programName,
                            fieldMapping: JSON.stringify(mappings)
                        })
                    });
                    
                    if (!response.ok) throw new Error(`Worker Error: ${await response.text()}`);
                    const result = await response.json();

                    logStatus('Worker response received.', 'success');
                    logStatus(`--- FINAL IMPORT SUMMARY ---`, 'info');
                    logStatus(`Worker Job ID: ${result.jobId}`, 'info');
                    logStatus(`Target Program: ${result.programName}`, 'info');
                    logStatus(`Status: ${result.status}`, result.status === 'Completed' ? 'success' : 'error');
                    logStatus(`Successes: ${result.successRows}`, 'success');
                    if (result.errorRows > 0) {
                        logStatus(`Errors: ${result.errorRows}`, 'error');
                    }
                } catch (error) {
                    logStatus(`Processing Error: ${error.message}`, 'error');
                } finally {
                    hideLoading(importButton);
                }
            };
            reader.readAsText(file);
        });
        
        /**
         * Transforms raw CSV content based on user mappings.
         * @param {string} rawCsv - Original CSV content.
         * @param {Object<string, string>} mappings - Map of CSV_Header -> Marketo_Field_Name.
         * @returns {string} Transformed CSV content.
         */
        function transformCsvForMarketo(rawCsv, mappings) {
            const lines = rawCsv.trim().split('\n');
            if (lines.length === 0) throw new Error("CSV file is empty.");
            
            const originalHeaders = lines[0].split(',').map(h => h.trim().replace(/['"]+/g, ''));
            const dataLines = lines.slice(1);
            const newHeaders = [];
            const headerIndicesToKeep = [];

            originalHeaders.forEach((header, index) => {
                const marketoField = mappings[header];
                if (marketoField) {
                    newHeaders.push(marketoField);
                    headerIndicesToKeep.push(index);
                }
            });
            
            if (!newHeaders.includes('email')) {
                throw new Error("Transformed CSV is missing 'email' column.");
            }

            let transformedCsv = newHeaders.join(',') + '\n';
            dataLines.forEach(line => {
                const columns = line.split(',');
                const newRow = [];
                headerIndicesToKeep.forEach(index => {
                    if (columns[index] !== undefined) {
                        newRow.push(columns[index].trim());
                    } else {
                        newRow.push('');
                    }
                });
                if (newRow.length > 0) {
                    transformedCsv += newRow.join(',') + '\n';
                }
            });
            return transformedCsv.trim();
        }

        // --- 1a. Program Name Autocomplete ---

        programNameInput.addEventListener('input', () => {
            clearTimeout(programSearchDebounce);
            programSearchDebounce = setTimeout(async () => {
                const query = programNameInput.value.trim();
                if (query.length < 3) {
                    programSuggestions.classList.add('hidden');
                    return;
                }
                
                try {
                    const response = await fetch(`/api/programs?search=${encodeURIComponent(query)}`);
                    if (!response.ok) return;
                    
                    const data = await response.json();
                    if (data.status === 'success' && data.programs.length > 0) {
                        programSuggestions.innerHTML = '';
                        data.programs.forEach(program => {
                            const item = document.createElement('div');
                            item.className = 'suggestion-item';
                            item.textContent = program.name;
                            item.onclick = () => {
                                programNameInput.value = program.name;
                                programSuggestions.classList.add('hidden');
                            };
                            programSuggestions.appendChild(item);
                        });
                        programSuggestions.classList.remove('hidden');
                    } else {
                        programSuggestions.classList.add('hidden');
                    }
                } catch (error) {
                    logStatus('Program search failed.', 'error');
                }
            }, 300);
        });
        
        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (e.target !== programNameInput) {
                programSuggestions.classList.add('hidden');
            }
        });

        // --- 2. Manual Lead Entry Logic ---

        manualImportForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const manualImportButton = document.getElementById('manualImportButton');
            showLoading(manualImportButton, 'Submitting Lead...');

            const leadData = {
                firstName: document.getElementById('manualFirstName').value,
                lastName: document.getElementById('manualLastName').value,
                email: document.getElementById('manualEmail').value,
                title: document.getElementById('manualTitle').value,
                company: document.getElementById('manualCompany').value,
                website: document.getElementById('manualWebsite').value,
                country: document.getElementById('manualCountry').value,
                Lead_Source_Detail__c: document.getElementById('manualCampaignCode').value, // Mapped field
                importProgramStatus: document.getElementById('manualProgramStatus').value, // Mapped field
                UTM_Source__c: document.getElementById('utmSource').value, // Hidden field
                jobTitleDescription: document.getElementById('manualRoleDescription').value // Hidden field
            };

            logStatus(`Submitting manual lead: ${leadData.email}`, 'info');

            try {
                const response = await fetch('/api/single-lead', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        programName: programNameInput.value.trim() || "Default Program", // Use bulk program name or a default
                        leads: [leadData] // Send as an array
                    })
                });

                if (!response.ok) throw new Error(`Worker Error: ${await response.text()}`);
                
                const result = await response.json();
                
                if (result.status === 'success' && result.result[0].status !== 'skipped') {
                    logStatus(`Successfully created/updated lead ID: ${result.result[0].id}`, 'success');
                    manualImportForm.reset();
                    dictationInput.value = ''; // Clear dictation too
                } else if (result.result[0].status === 'skipped') {
                    logStatus(`Lead skipped: ${result.result[0].reasons[0].message}`, 'error');
                } else {
                    throw new Error('Failed to submit lead.');
                }
            } catch (error) {
                logStatus(`Submission Error: ${error.message}`, 'error');
            } finally {
                hideLoading(manualImportButton);
            }
        });

        // --- 2a. Voice Dictation Logic ---

        if ('webkitSpeechRecognition' in window) {
            speechRecognition = new webkitSpeechRecognition();
            speechRecognition.continuous = false;
            speechRecognition.interimResults = false;
            speechRecognition.lang = 'en-US';

            speechRecognition.onstart = () => {
                dictationStatus.textContent = 'Status: Listening...';
                micButton.classList.add('animate-pulse', 'bg-red-500');
            };

            speechRecognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                dictationInput.value = transcript;
            };

            speechRecognition.onerror = (event) => {
                dictationStatus.textContent = `Error: ${event.error}`;
                logStatus(`Speech API Error: ${event.error}`, 'error');
            };

            speechRecognition.onend = () => {
                dictationStatus.textContent = 'Status: Processing...';
                micButton.classList.remove('animate-pulse', 'bg-red-500');
                if (dictationInput.value) {
                    dictationStatus.textContent = 'Status: Transcribed. Click Parse.';
                } else {
                    dictationStatus.textContent = 'Status: Idle.';
                }
            };

            micButton.addEventListener('click', () => {
                if (speechRecognition) {
                    speechRecognition.start();
                }
            });

        } else {
            dictationStatus.textContent = 'Status: Speech recognition not supported in this browser.';
            micButton.disabled = true;
            parseDictationButton.disabled = true;
        }

        parseDictationButton.addEventListener('click', async () => {
            const text = dictationInput.value.trim();
            if (!text) {
                logStatus('No dictated text to parse.', 'error');
                return;
            }
            
            showLoading(parseDictationButton, 'Parsing Text...');
            logStatus('Sending dictated text to Gemini for parsing...', 'info');

            try {
                const response = await fetch('/api/parse-leads', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        // Provide the schema for a single lead
                        jsonSchema: {
                            type: "OBJECT",
                            properties: {
                                "firstName": { "type": "STRING" },
                                "lastName": { "type": "STRING" },
                                "email": { "type": "STRING" },
                                "company": { "type": "STRING" },
                                "title": { "type": "STRING" },
                                "website": { "type": "STRING" },
                                "country": { "type": "STRING" }
                            }
                        }
                    })
                });

                if (!response.ok) throw new Error(`Worker Error: ${await response.text()}`);

                const result = await response.json();
                
                if (result.status === 'success' && result.data) {
                    const lead = result.data; // Expecting a single object
                    
                    // Fill the manual form
                    document.getElementById('manualFirstName').value = lead.firstName || '';
                    document.getElementById('manualLastName').value = lead.lastName || '';
                    document.getElementById('manualEmail').value = lead.email || '';
                    document.getElementById('manualTitle').value = lead.title || '';
                    document.getElementById('manualCompany').value = lead.company || '';
                    document.getElementById('manualWebsite').value = lead.website || '';
                    document.getElementById('manualCountry').value = lead.country || '';
                    
                    logStatus('Successfully parsed dictated text and filled form.', 'success');
                } else {
                    throw new Error('Gemini did not return valid lead data.');
                }
            } catch (error) {
                logStatus(`Parsing Error: ${error.message}`, 'error');
            } finally {
                hideLoading(parseDictationButton);
            }
        });

        // --- 3. Gemini Unstructured Data Parser ---

        processUnstructuredButton.addEventListener('click', async () => {
            const text = unstructuredInput.value.trim();
            if (!text) {
                logStatus('No unstructured data provided.', 'error');
                return;
            }
            
            showLoading(processUnstructuredButton, 'Processing Data...');
            structuredOutput.value = 'Asking Gemini to parse the data...';
            logStatus('Sending data to Gemini for parsing...', 'info');

            try {
                // This is the JSON schema Gemini will follow
                const jsonSchema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "email": { "type": "STRING" },
                            "firstName": { "type": "STRING" },
                            "lastName": { "type": "STRING" },
                            "company": { "type": "STRING" }
                        },
                        required: ["email"]
                    }
                };

                const response = await fetch('/api/parse-leads', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, jsonSchema })
                });

                if (!response.ok) throw new Error(`Worker Error: ${await response.text()}`);
                
                const result = await response.json();
                
                if (result.status === 'success' && Array.isArray(result.data)) {
                    // Convert JSON to CSV
                    const headers = ["email", "firstName", "lastName", "company"];
                    let csv = headers.join(',') + '\n';
                    result.data.forEach(row => {
                        csv += headers.map(header => `"${row[header] || ''}"`).join(',') + '\n';
                    });
                    
                    structuredOutput.value = csv;
                    copyCsvButton.classList.remove('hidden');
                    logStatus('Successfully parsed data into CSV format.', 'success');
                } else {
                    throw new Error('Gemini did not return a valid data array.');
                }
            } catch (error) {
                logStatus(`Parsing Error: ${error.message}`, 'error');
                structuredOutput.value = `Error: ${error.message}`;
            } finally {
                hideLoading(processUnstructuredButton);
            }
        });

        copyCsvButton.addEventListener('click', () => {
            // Use execCommand for broader compatibility in iFrames
            structuredOutput.select();
            try {
                document.execCommand('copy');
                logStatus('CSV content copied to clipboard!', 'success');
            } catch (err) {
                logStatus('Failed to copy. Please copy manually.', 'error');
            }
        });

        // --- 3a. Gemini Job Title Describer ---

        describeTitleButton.addEventListener('click', async () => {
            const title = manualTitleInput.value.trim();
            if (!title) {
                logStatus('Please enter a Job Title first.', 'error');
                return;
            }
            
            showLoading(describeTitleButton, '...');
            logStatus(`Asking Gemini to describe: ${title}`, 'info');

            try {
                const response = await fetch('/api/describe-title', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: title })
                });

                if (!response.ok) throw new Error(`Worker Error: ${await response.text()}`);
                
                const result = await response.json();
                
                if (result.status === 'success' && result.description) {
                    manualRoleDescriptionInput.value = result.description;
                    logStatus('Role description generated and stored.', 'success');
                    // Optionally show it to the user
                    alert(`Role Description Generated:\n\n${result.description}\n\nThis will be saved to the 'jobTitleDescription' field.`);
                } else {
                    throw new Error('Gemini did not return a valid description.');
                }
            } catch (error) {
                logStatus(`Description Error: ${error.message}`, 'error');
            } finally {
                hideLoading(describeTitleButton);
            }
        });
        
    </script>
</body>
</html>
